# Next.js Tutorial

<br/><br/>

## layout.js와 page.js의 관계
`layout.js`의 `children` prop은 `page.js`의 리턴값이다.

<img src="public/img/layout_page.png" width="70%" alt="layout_page" />

```jsx
//layout.js
export default function RootLayout({ children }) {
  return (
    <html>
      <body>{children}</body>
    </html>
  )
}
```

<br/>

## 빌드와 배포
빌드는 애플리케이션을 최적화하고 실제 서버에서 호스팅하기 위한 효율적인 배포 버전을 생성하는 필수 단계이다. 이로써, 용량을 최소화하고 불필요한 메세지를 콘솔에 출력하지 않는 등의 성능 향상을 기대할 수 있다.

### build
`.next` 폴더 하위에 배포 가능한 버전의 애플리케이션을 생성한다
```bash
npm run build
```

### start
생성된 배포 버전을 바탕으로 서비스를 시작한다
```bash
npm run start
```

<br/>

## metadata
`layout.js` 혹은 `page.js`에서 `metadata`를 `export`하면 html의 `<head>`안에 내용을 생성할 수 있다

```jsx
export const metadata = {
  title: 'WEB tutorial',
  description: 'Generated by rjk',
}
```
<img src="public/img/metadata.png" width="50%" alt="metadata" />

<br/>

## Routing
사용자가 접속한 URL의 경로에 따라서 해당하는 콘텐츠를 제공하는 작업을 `라우팅`이라고 한다.<br/>
Next.js는 간편하고 직관적인 라우팅을 제공하며, 프로젝트의 복잡성을 효과적으로 관리할 수 있도록 도와준다.

### 0. URL 용어 정리
`/dashboard/analytics/` 부분을 `path`, <br/>
`dashboard`와 `analytics` 각각을 `segment`라고 한다

<img src="public/img/url.png" width="60%" alt="url" />

<br/>

### 1. 페이지 만드는 방법
`create/pages.js` 파일을 생성하면 `/create` 페이지가 올바르게 출력된다
```jsx
// app/create/page.js
export default function Create(){
  return <>
    Create!!
  </>
}
```
#### 알 수 있는 것
- `app` 하위의 폴더는 세그먼트를 의미한다
- `app/create/page.js` 파일의 반환 값이 상위 컴포넌트의 `layout.js`의 `children` prop으로 전달된다.

<br/>

### 2. Next.js의 라우팅 로직
Next.js는 레이아웃의 중첩을 허용한다. 때문에 URL 경로의 세그먼트에 따라 콘텐츠를 찾고, 해당 콘텐츠가 위치한 폴더의 `layout.js`를 시작으로 상위 폴더를 탐색하면서 `layout.js`로 감싸준다.

#### 중첩된 하위 레이아웃 만들기 예시
`app/create/page.js`를 감싸는 `app/create/layout.js` 하위 레이아웃 파일을 생성한다.<br/>
이처럼 하위 레이아웃이 있다면, `app/create/layout.js`로 `app/create/page.js`를 포장한 후에 `app/layout.js`로 포장한다.

```jsx
// props : app/create/page.js 리턴값
export default function Layout(props){
  return (
    <form>
      <h2>Create</h2>
      {props.children}
    </form>
  )
}
```

<br/>

### 3. 동적 라우팅(dynamic routing)
`read/1`, `read/2` 의 1, 2와 같이 가변적으로 변경되는 경로를 처리해보자.

#### 페이지 생성
`/app/read/[id]/page.js` 파일을 다음과 같이 생성하면 `/read/1` 페이지가 올바르게 출력된다

#### 라우팅 로직
`/read/1`로 접속하면 1의 자리에 해당하는 폴더인 [id]의 이름을 기준으로 props를 만들어서 주입해준다. 이렇게 주입된 값을 활용하여 다양한 작업을 처리할 수 있다.
```jsx
export default function Read(props){
  cosole.log(props); //{ params: { id: 1 } }
  
  return (
    <>
      <h2>Read</h2>
      parameter : {props.params.id}
    </>
  )
}
```
<img src="public/img/routing.png" width="50%" alt="routing" />

<br/>

## SPA(Single Page Application)
하나의 페이지에서 모든 작업을 처리하는 앱을 의미한다<br/>
서버로부터 데이터를 가져와야 한다면, ajax와 같은 방법을 사용하여 데이터를 동적으로 로드한다

### Link
`Link`는 Next.js에서 SPA를 간단하게 구현하는데 도움을 주는 도구이다
```jsx
<Link href='/'>Home</Link>
```
    - 링크를 클릭하면 페이지 전체가 다시 로드되지 않고, 필요한 콘텐츠만 업데이트된다
    - 이미 방문한 페이지는 캐시되어 다시 다운로드하지 않음
    - 미리 페이지를 다운로드하고, 실제 요청이 있을 때 클라이언트 측에서 즉시 응답

<br/>

## 정적인 자원 사용하기(public)
이미지, robots.txt, favicon.ico와 같은 파일을 static asset라고 한다<br/>
Next.js에서 정적 자원을 로딩하는 방법을 알아보자


### 이미지 로딩 해보기
#### 1. public 폴더에 이미지 추가

<img src="public/img/static_img.png" width="30%" alt="static_img" />

#### 2. 이미지 사용
슬래시(`/`)는 `public` 폴더의 하위를 가리킨다
```html
<img src="/hello.png" width="80" alt="" />
```

<br/>

## 전역 스타일 지정
전역적으로 디자인을 적용하고 싶다면 `app/global.css`를 수정하면 된다

<br/>

## Json-server를 사용하여 백엔드 구축하기
Next.js는 백엔드까지 제공하는 풀 스택 프레임워크로, Route Handlers를 사용하면 별도의 백엔드를 설정하지 않고도 Next.js API 서버를 구축할 수 있다. Json-server를 활용하여 간단하게 백엔드를 구축해보자

### 1. `json-server` 실행
```bash
npx json-server --port 9999 --watch db.json
```

### 2. `db.json` 파일 생성 확인 및 수정
```json
{
  "topics": [
    {
      "id": 1,
      "title": "html",
      "body": "html is .."
    },
    {
      "id": 2,
      "title": "css",
      "body": "css is .."
    }
  ],
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": "typicode"
    }
  ],
}
```

### 3. 지정한 포트로 접속하여 확인
<img src="public/img/json-server.png" width="60%" alt="json-server" />
  
### 4. 통신해보기
<img src="public/img/fetch.png" width="70%" alt="fetch" />

<br/>

## 서버 컴포넌트 vs 클라이언트 컴포넌트
[🔗 서버 컴포넌트(Server Component)](/서버%20컴포넌트(Server%20Component).md)

<br/>

## 환경변수
코드에 직접 포함할 수 없는 정보는 환경변수를 활용하여 관리하는 것이 좋다.<br/>
예를 들어, 실제 서버와 개발 서버의 주소가 다른 경우, 환경변수를 사용하여 서버 주소를 효과적으로 관리할 수 있다.

### 1. 환경변수 파일 생성
루트 디렉토리에 `.env.local` 파일을 생성하고, 환경변수를 추가한다.<br/>
이때, `NEXT_PUBLIC_` 접두사가 없으면 server component에서만 사용할 수 있고, client component에서는 접근할 수 없다. 이 접두사는 DB_PASSWORD와 같은 비밀 정보를 보호하기 위한 안전장치로 사용된다.
```bash
# .env.local
NEXT_PUBLIC_API_URL=http://localhost:9999
```

### 2. 코드 내의 사용
환경변수는 `process.env.변수명`을 사용하여 가져올 수 있다
```jsx 
const resp = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/topics/`);
```